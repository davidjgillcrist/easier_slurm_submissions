#!/bin/zsh

if [ -z "$1" ]; then
    Usqueue
elif [ -z "$2" ]; then
    linesShown=$(( $1 + 3 ))
    Usqueue | head -n "$linesShown"
else
    headerSize=3 # Full height of the header part of Usqeue
    fullEscape=false
    numOnQueue=$(( $(Usqueue | wc -l) - headerSize ))
    infoLines=(" ") # First entry is a blank line to create buffer between Usqueue and infoLines
    infoLines+=("# of uncompleted jobs: $numOnQueue")
    removeUnwantedLine=${#infoLines[@]}
    infoLines+=("Press q or Q to exit.")
    numInfoLines=${#infoLines[@]}
    if (( numOnQueue > 0 )); then
        linesShown=$(( $2 + headerSize ))
        isFirst=1
        while (( numOnQueue > 0 )); do
            if (( isFirst )); then
                isFirst=0
            else
                clear_lines "$(( linesShown + numInfoLines ))"
                infoLines[$removeUnwantedLine]="# of uncompleted jobs: $numOnQueue"
            fi
            if (( linesShown > numOnQueue )); then
                linesShown=$(( numOnQueue + headerSize ))
            fi
            Usqueue | head -n "$linesShown"
            printf '%s\n' "${infoLines[@]}"
            printf '%s' "Input: "
            if read -rs -k1 -t $1 key; then
                case "$key" in
                    Q|q)
                        clear_lines 1
                        printf '%s\n' "Input: $key"
                        printf '%s\n' "Exiting squeue monitoring..."
                        fullEscape=true
                        break 
                        ;;
                esac
            fi
            numOnQueue=$(( $(Usqueue | wc -l) - headerSize ))
            while (( numOnQueue < 0 )); do
                numOnQueue=$(( $(Usqueue | wc -l) - headerSize ))
            done
        done
    else
        emptyJobs=$'\033[1;33mWarning:\033[0m There are no jobs running on Unity right now. Either your script hasn\'t finished submitting them, they\'ve completed already, or you forgot to submit any.'
    fi

    if $fullEscape; then
        # Do Nothing
    else
        timer=17
        numRings=3
        spacingSecs=0.875
        if [[ ! -z $emptyJobs ]]; then
            printf '%s' "$emptyJobs"
        else
            clear_lines "$(( linesShown + numInfoLines ))"
            finalOutput=$'All jobs have either \033[1;32mfinished\033[0m running on Unity, have \033[1;31mfailed\033[0m to be picked up by Slurm, or were \033[1;31m aborted\033[0m in their execution due to errors. Check your various outfile directories for details.'
            cols=$(tput cols)
            wrappedLines=$(echo "$finalOutput" | fold -s -w $cols)
            echo "$wrappedLines" | while IFS= read -r line; do
                printf "%s\n" "$line"
            done 
        fi 
        unset "infoLines[$removeUnwantedLine]"
        printf '%s\n' "${infoLines[@]}"
        printf '%s' "Input: "
        while (( timer > 0 )); do
            for i in {1..$numRings}; do
                print -n "\a"
                sleep 1.125
            done
            if read -rs -k1 -t $spacingSecs key; then
                case "$key" in
                    Q|q)
                        clear_lines 1
                        printf '%s\n' "Input: $key"
                        printf '%s\n' "Exiting squeue monitoring..."
                        break
                        ;;
                esac
            fi
            (( timer-- ))
        done
    fi
fi
